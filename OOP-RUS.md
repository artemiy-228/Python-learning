# ООП

## Классы

### Классы


В центре объектно-ориентированного программирования (ООП) находятся объекты, которые создаются с использованием классов.

Класс описывает, каким будет объект, но он отделен от самого объекта. Другими словами, класс можно описать как схему, описание или определение объекта.

Вы можете использовать один и тот же класс в качестве схемы для создания нескольких разных объектов.

Классы создаются с использованием ключевого слова class и блока с отступом, который содержит методы класса (которые являются функциями).

Ниже приведен пример простого класса и его объектов.

    class Cat:
      def __init__(self, color, legs):
        self.color = color
        self.legs = legs
        
    felix = Cat("ginger", 4)
    rover = Cat("dog-colored", 4)
    stumpy = Cat("brown", 3)

> Подсказка: этот код определяет класс с именем Cat, который имеет два атрибута: цвет и ноги.Затем класс используется для создания 3 отдельных объектов этого класса.

### __init__ / Конструкторы

Метод **__init__** — самый важный метод в классе.

Это вызывается при создании экземпляра (объекта) класса с использованием имени класса в качестве функции.

Все методы должны иметь **self** в качестве первого параметра, хотя он не передается явно, Python добавляет аргумент **self** в список для вас; вам не нужно включать его при вызове методов. В определении метода **self** относится к экземпляру, вызывающему метод.

Экземпляры класса имеют **атрибуты**, которые представляют собой фрагменты данных, связанных с ними.
В этом примере экземпляры **Cat** имеют атрибуты **color** и **legs**. Доступ к ним можно получить, поставив **точку** и имя атрибута после экземпляра.
Таким образом, в методе **__init__** **self.attribute** можно использовать для установки начального значения **атрибутов** экземпляра.

> Подсказка: в приведенном выше примере метод **__init__** принимает два аргумента и присваивает их атрибутам объекта. Метод **__init__** называется конструктором класса.

### Методы

Классы могут иметь другие **методы**, определенные для добавления к ним функциональности.
Помните, что все методы должны иметь **self** в качестве первого параметра.
Доступ к этим методам осуществляется с использованием того же синтаксиса **точки**, что и для атрибутов.

***

## Наследование

### Наследование

**Наследование** обеспечивает возможность совместного использования функций между классами.

Представьте себе несколько классов: **Кошка, Собака, Кролик** и так далее. Хотя они могут отличаться в чем-то (только **Собака** может иметь метод **лай**), они, вероятно, будут похожи в других (все они имеют **атрибуты цвета** и **имя**). .
Это сходство может быть выражено в том, что все они наследуются от **суперкласса Animal**, который содержит общие функции.
Чтобы **наследовать** класс от другого класса, поместите имя суперкласса в круглые скобки после имени класса.

	class Animal: 
      def __init__(self, name, color):
        self.name = name
        self.color = color
    class Cat(Animal):
      def purr(self):
        print("Purr...")
        
    class Dog(Animal):
      def bark(self):
        print("Woof!")

    fido = Dog("Fido", "brown")
    print(fido.color)
    fido.bark()

### Наследование

Класс, который наследуется от другого класса, называется **подклассом**.
Класс, унаследованный от, называется **суперклассом**.
Если класс наследуется от другого с теми же атрибутами или методами, он переопределяет их.

    class Wolf: 
      def __init__(self, name, color):
        self.name = name
        self.color = color
  
      def bark(self):
         print("Grr...")
         
    class Dog(Wolf):
      def bark(self):
        print("Woof")
        
    husky = Dog("Max", "grey")
    husky.bark() 


> Подсказка: в приведенном выше примере Wolf — это надкласс, а Dog — подкласс.

### Наследование

Функция super — полезная функция, связанная с наследованием, которая ссылается на родительский класс. Его можно использовать для поиска метода с определенным именем в **суперклассе** объекта.

    class A:
      def spam(self):
        print(1)
        
    class B(A):
      def spam(self):
        print(2)
        super().spam()
            
    B().spam()

> Hint: **super().spam()** calls the spam method of the **superclass**.

> Подсказка: **super().spam()** вызывает спам-метод **суперкласса**.

***

## Магические методы & Операторы перегрузки

### Магические методы

**Магические методы** — это специальные методы, имена которых имеют **двойные символы подчеркивания** в начале и в конце.

Они также известны как **дандеры**.

Пока что мы столкнулись только с **__init__**, но есть и другие.

Они используются для создания функциональности, которую нельзя представить в виде обычного метода.

Одним из их распространенных применений является **перегрузка оператора**.

Это означает определение операторов для пользовательских классов, которые позволяют использовать в них такие операторы, как + и *.

Пример магического метода: **__add__** для + 

    class Vector2D:
      def __init__(self, x, y):
        self.x = x
        self.y = y
      def __add__(self, other):
        return Vector2D(self.x + other.x, self.y + other.y)
        
    first = Vector2D(5, 7)
    second = Vector2D(3, 9)
    result = first + second
    print(result.x)
    print(result.y)

> Подсказка: метод **__add__** позволяет определить пользовательское поведение для оператора + в нашем классе.
Как видите, он добавляет соответствующие атрибуты объектов и возвращает новый объект, содержащий результат.
Как только он определен, мы можем добавить два объекта класса вместе.

### Магические методы

Больше магических методов для стандартных операторов

* __sub__ для -

* __mul__ для *

* __truediv__ для /

* __floordiv__ для //

* __mod__ для %

* __pow__ для **

* __and__ для &

* __xor__ для ^

* __or__ для |

Выражение x + y преобразуется в x.**__add__**(y).

Однако, если x не реализовал **__add__**, а x и y имеют разные типы, то вызывается y.**__radd__**(x).

Существуют эквивалентные r методов для всех только что упомянутых магических методов.

    class SpecialString:
      def __init__(self, cont):
        self.cont = cont
        
      def __truediv__(self, other):
        line = "=" * len(other.cont)
        return "\n".join([self.cont, line, other.cont])
        
    spam = SpecialString("spam")
    hello = SpecialString("Hello world!")
    print(spam / hello)

> Подсказка: в приведенном выше примере мы определили операцию деления для нашего класса SpecialString.


### Магические методы для сравнения

Python так-же содержит магические методы для сравнения

* __lt__ для <

* __le__ для <=

* __eq__ для ==

* __ne__ для !=

* __gt__ для >

* __ge__ для >=

Если __ne__ не реализовано, возвращается значение, противоположное __eq__.
Других отношений между другими операторами нет.


    class SpecialString:
      def __init__(self, cont):
        self.cont = cont
        
      def __gt__(self, other):
        for index in range(len(other.cont)+1):
          result = other.cont[:index] + ">" + self.cont
          result += ">" + other.cont[index:]
          print(result)
          
    spam = SpecialString("spam")
    eggs = SpecialString("eggs")
    spam > eggs



> Подсказка: Как видите, вы можете определить любое пользовательское поведение для перегруженных операторов.

### Магические методы 
Есть несколько магических методов что бы  заставить классы работать как контейнеры.

* __len__ для len()

* __getitem__ для индексации

* __setitem__ для присвоения индексированным значениям

* __delitem__ для удаления индексированных значений

* __iter__ для итерации по циклу

* __contains__ для проверки вхождения(например in)

Есть много других магических методов, которые мы не будем здесь рассматривать, например __call__ для вызова объектов как функций, и __int__, __str__ и им подобных для преобразования объектов во встроенные типы.

    import random
    
    class VagueList:
      def __init__(self, cont):
        self.cont = cont
        
      def __getitem__(self, index):
        return self.cont[index + random.randint(-1, 1)]
        
      def __len__(self):
        return random.randint(0, len(self.cont)*2)
        
    vague_list = VagueList(["A", "B", "C", "D", "E"])
    print(len(vague_list))
    print(len(vague_list))
    print(vague_list[2])
    print(vague_list[2])

> Подсказка: Мы переопределили функцию len() для класса VagueList, чтобы она возвращала случайное число.
Функция индексирования также возвращает случайный элемент в диапазоне из списка на основе выражения.

*** 

## Скрытие данных

### Скрытие данных

Ключевой частью объектно-ориентированного программирования является инкапсуляция, которая включает упаковку связанных переменных и функций в один простой в использовании объект — экземпляр класса.

Родственная концепция — скрытие данных, в которой говорится, что детали реализации класса должны быть скрыты, а для тех, кто хочет использовать класс, должен быть представлен чистый стандартный интерфейс.

В других языках программирования это обычно делается с помощью закрытых методов и атрибутов, которые блокируют внешний доступ к определенным методам и атрибутам в классе.

Философия Python немного отличается. Часто говорится, что «мы все здесь взрослые по обоюдному согласию», что означает, что вы не должны произвольно ограничивать доступ к частям класса. Следовательно, нет способов обеспечить, чтобы метод или атрибут были строго закрытыми.

> Подсказка. Тем не менее, есть способы отговорить людей от доступа к частям класса, например, обозначив, что это деталь реализации, которую следует использовать на свой страх и риск.

### Скрытие данных

Слабо приватные методы и атрибуты имеют один подчеркивание в начале.

Это сигнализирует о том, что они являются частными и не должны использоваться внешним кодом. Однако в основном это всего лишь соглашение, которое не препятствует доступу к ним внешнего кода.

    class Queue:
      def __init__(self, contents):
          self._hiddenlist = list(contents)
        
      def push(self, value):
          self._hiddenlist.insert(0, value)
         
      def pop(self):
          return self._hiddenlist.pop(-1)
        
      def __repr__(self):
          return "Queue({})".format(self._hiddenlist)
          
    queue = Queue([1, 2, 3])
    print(queue)
    queue.push(0)
    print(queue)
    queue.pop()
	print(queue)
	print(queue._hiddenlist)

> Hint: В приведенном выше коде атрибут _hiddenlist помечен как приватный, но к нему по-прежнему можно получить доступ во внешнем коде.
Магический метод __repr__ используется для строкового представления экземпляра.

### Скрытие данных

Строгие частные методы и атрибуты имеют двойное подчеркивание в начале своего имени. Это приводит к тому, что их имена искажаются, а это означает, что к ним нельзя получить доступ извне класса.

Цель этого не в том, чтобы гарантировать их приватность, а во избежание ошибок, если есть подклассы, которые имеют методы или атрибуты с теми же именами.

Доступ к методам с измененным именем по-прежнему можно получить извне, но под другим именем. К методу __privatemethod класса Spam можно было получить доступ извне с помощью _Spam__privatemethod.

    class Spam:
      __egg = 7
      def print_egg(self):
        print(self.__egg)
        
	s = Spam()
	s.print_egg()
	print(s._Spam__egg)
	print(s.__egg)
> Подсказка. По сути, Python защищает эти члены, внутренне изменяя имя, чтобы оно включало имя класса.

***

## Методы класса

### Методы класса

Методы объектов, которые мы рассмотрели до сих пор, вызываются экземпляром класса, который затем передается параметру self метода.

Методы класса разные — они вызываются классом, который передается в параметр cls метода.

Обычно они используются в фабричных методах, которые создают экземпляр класса с использованием параметров, отличных от тех, которые обычно передаются конструктору класса.

Методы класса помечаются декоратором classmethod.

    class Rectangle:
      def __init__(self, width, height):
        self.width = width
        self.height = height
        
      def calculate_area(self):
        return self.width * self.height
        
      @classmethod
      def new_square(cls, side_length):
        return cls(side_length, side_length)
    square = Rectangle.new_square(5)
    print(square.calculate_area())

new_square — это метод класса, который вызывается в классе, а не в экземпляре класса. Он возвращает новый объект класса cls.

> Подсказка: Технически параметры self и cls — это просто соглашения; их можно поменять на что угодно. Тем не менее, им следуют повсеместно, поэтому разумно придерживаться их

### Статические методы

Статические методы аналогичны методам класса, за исключением того, что они не получают никаких дополнительных аргументов; они идентичны обычным функциям, принадлежащим классу.
Они отмечены декоратором staticmethod.

    class Pizza:
      def __init__(self, toppings):
        self.toppings = toppings
        
      @staticmethod
      def validate_topping(topping):
        if topping == "pineapple":
          raise ValueError("No pineapples!")
        else:
          return True
          
    ingredients = ["cheese", "onions", "spam"]
    if all(Pizza.validate_topping(i) for i in ingredients):
      pizza = Pizza(ingredients) 

> Подсказка: Статические методы ведут себя как обычные функции, за исключением того факта, что их можно вызывать из экземпляра класса.

***

## Свойства

### Свойства

Свойства предоставляют способ настройки доступа к атрибутам экземпляра.

Они создаются путем размещения декоратора свойства над методом, что означает, что при доступе к атрибуту экземпляра с тем же именем, что и у метода, вместо этого будет вызываться метод.

Одно из распространенных применений свойства — сделать атрибут доступным только для чтения.

    class Pizza:
      def __init__(self, toppings):
        self.toppings = toppings
        
      @property
      def pineapple_allowed(self):
        return False
        
    pizza = Pizza(["cheese", "tomato"])
    print(pizza.pineapple_allowed)
    pizza.pineapple_allowed = True

### Свойства

Свойства также можно установить, определив функции установки/получения.

Функция сеттер устанавливает значение соответствующего свойства.

Геттер получает значение.

Чтобы определить сеттер, вам нужно использовать декоратор с тем же именем, что и свойство, за которым следует точка и ключевое слово сеттера.

То же самое относится к определению функций получения

    class Pizza:
      def __init__(self, toppings):
        self.toppings = toppings
        self._pineapple_allowed = False
        
      @property
      def pineapple_allowed(self):
        return self._pineapple_allowed
        
      @pineapple_allowed.setter
      def pineapple_allowed(self, value):
        if value:
          password = input("Enter the password: ")
          if password == "Sw0rdf1sh!":
            self._pineapple_allowed = value
          else:
            raise ValueError("Alert! Intruder!")
            
    pizza = Pizza(["cheese", "tomato"])
    print(pizza.pineapple_allowed)
    pizza.pineapple_allowed = True
    print(pizza.pineapple_allowed)

***
Конец! Если вам понравилось, обязательно используйте это для вашего обучения!